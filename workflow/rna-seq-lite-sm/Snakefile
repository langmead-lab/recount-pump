INDEX_DIR=os.environ.get('RECOUNT_REF')
TEMP=os.environ.get('RECOUNT_TEMP')
INPUT=os.environ.get('INPUT', 'accessions.txt')
OUTPUT=os.environ.get('OUTPUT', 'output')

def get_accessions(wildcards):
    """
    Grouping of SRRs with the same SRP could happen here
    """
    for fn in INPUT.split():
        with open(fn, 'r') as fh:
            for ln in fh:
                if ln.count(',') < 2:
                    continue
                toks = ln.rstrip().split(',')
                assert len(toks) == 3
                # SRR,SRP,genome
                # e.g. SRR1557855,SRP045778,ce10
                fn = '%s_%s_%s.txt' % (toks[0], toks[1], toks[2])
                yield os.path.join(OUTPUT, fn)

rule all:
    input:
        get_accessions

rule report:
    input:
        'sorted_bam/{trio}.sorted.bam'
    output:
        '{OUTPUT}/{trio}.txt'
    shell:
        """
        wc -l {input} > {output}
        """

rule sort:
    input:
        'sam/{trio}.sam'
    output:
        bam=temp("temp/{trio}.bam"),
        sorted_bam='sorted_bam/{trio}.sorted.bam',
        sorted_bai='sorted_bam/{trio}.sorted.bam.bai'
    shell:
        """
        sambamba view -S -f bam {input} > {output.bam}
        sambamba sort --tmpdir={TEMP} -p -m 10G -o {output.sorted_bam} {output.bam}
        sambamba index {output.sorted_bam}
        """

rule align:
    input:
        reads0='reads/{trio}_0.fastq',
        reads1='reads/{trio}_1.fastq',
        reads2='reads/{trio}_2.fastq',
        index=lambda wildcards: '%s/%s/hisat2_idx/genome.1.ht2' % (INDEX_DIR, wildcards.trio.split('_')[2])
    output:
        sam='sam/{trio}.sam', log='logs/{trio}.log'
    params:
        index_base=lambda wildcards: '%s/%s/hisat2_idx/genome' % (INDEX_DIR, wildcards.trio.split('_')[2])
    shell:
        """
        if [[ -s reads/{wildcards.trio}_0.fastq ]] ; then
            hisat2 -x {params.index_base} --min-intronlen 20 \
                -U {input.reads0} \
                -S {output.sam} -t 2>{output.log}
        else
            hisat2 -x {params.index_base} --min-intronlen 20 \
                -1 {input.reads1} -2 {input.reads2} \
                -S {output.sam} -t 2>{output.log}
        fi
        """

rule sra_fastq:
    output:
        'reads/{trio}_0.fastq', 'reads/{trio}_1.fastq', 'reads/{trio}_2.fastq'
    params:
        srr=lambda wildcards: wildcards.trio.split('_')[0]
    shell:
        """
        fastq-dump {params.srr} --split-files -I --skip-technical
        test -f {params.srr}_2.fastq || mv {params.srr}_1.fastq {params.srr}_0.fastq
        for i in 0 1 2 ; do
            touch {params.srr}_$i.fastq
            mv {params.srr}_$i.fastq reads/{wildcards.trio}_$i.fastq
        done
        """
